#ifndef CALLER_HPP_INCLUDED
#define CALLER_HPP_INCLUDED

#include <string>

#include "util.hpp"
#include "metacontext.hpp"
#include "metaclass.hpp"
#include "tuple_util.hpp"
#include "exceptions.hpp"

using namespace std;

namespace meta
{
//! Method caller
/*!
    Class responsible for taking parameters and calling IFnWrap object.
*/
    class Caller
    {
    private:
        string _mname;
        PolyWrapper<IFnWrap> _fn;
        mutable MetaContext _context;
        mutable MetaState &_state;
    public:
        /*!
            Constructor
            \param mname    The method name
            \param fn       IFnWrap object
            \param context  Method execution context
            \param state    Object state
        */
        Caller(const string &mname, PolyWrapper<IFnWrap> fn, MetaContext context, MetaState &state) :
                _mname(mname), _fn(fn), _context(context), _state(state) {}

        /*!
            Call operator for tuple
            \param arg  A tuple containing the method arguments
            \return     The method return value
        */
        template<typename Tret, typename Tparam> Tret operator()(Tparam arg) const
        {
            if (!_fn().TypeCheck(TypeID<Tret>(),TypeID<Tparam>()))
            {
                throw Exceptions::TypeMismatch();
            }
            _context.ManyArgs=MkConvert(arg);
            MetaInfo ifo(_state, _context);
            if (TypeID<Tret>()==TypeID<NO_RETURN>())
            {
                _fn().Call(ifo, any(arg));
                return Nothing;
            }
            else return any_cast<Tret>(_fn().Call(ifo, any(arg)));
        }
        /*!
            Call method for tuple
            \param arg  A tuple containing the method arguements
            \return     The method return value
        */
        template<typename Tret, typename Tparam> Tret Call(Tparam arg) const
        {
            return operator()<Tret>(arg);
        }
        /*!
            Call operator for vector<any> (many).
            \param args     A vector<any> containing the method arguements
            \return         The method return value
        */
        template<typename Tret> Tret operator()(many args) const
        {
            _context.ManyArgs=MkConvert(args);
            MetaInfo ifo(_state, _context);
            return any_cast<Tret>(_fn().Call(ifo, args));
        }
        /*!
            Call method for vector<any> (many).
            \param args     A vector<any> containing the method arguements
            \return         The method return value
        */
        template<typename Tret> Tret Call(many args) const
        {
            return operator()<Tret>(args);
        }
        /*!
            Call operator for tuple with no return value
            \param arg      A typle containing the method arguements
        */
        template<typename Tparam> void operator()(Tparam arg) const
        {
            operator()<NO_RETURN>(arg);
        }
        /*!
            Call method for tuple with no return value
            \param arg      A typle containing the method arguements
        */
        template<typename Tparam> void Call(Tparam arg) const
        {
            operator()<Tparam>(arg);
        }
        /*!
            Call operator with no arguements
            \return     The method return value
        */
        template<typename Tret> Tret operator()() const
        {
            return operator()<Tret>(NullValue);
        }
        /*!
        template<typename Tret> Tret Call() const
        {
            return operator()<Tret>();
        }
        template<typename Tret, typename Tparam> bool TypeCheck()
        {
            return _fn().TypeCheck(TypeID<Tret>(),TypeID<Tparam>());
        }
        any operator()(many args) const;
        any Call(many args) const;
        void operator()() const;
        void Call() const;
        string GetName() const;
        const ITypeInfo& GetReturnType() const;
        vector<PolyWrapper<ITypeInfo> > GetParamTypes() const;

    };

}
#endif // CALLER_HPP_INCLUDED
